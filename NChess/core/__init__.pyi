import numpy as np
from typing import Sequence, overload

class Move(int):    
    @property
    def from_(self) -> int: ...
    
    @property
    def to_(self) -> int: ...
    
    @property
    def promote(self) -> int: ...

    @property
    def move_type(self) -> int: ...
    
    @property
    def is_castle(self) -> int: ...
    
    @property
    def is_enpassant(self) -> bool: ...
    
    @property
    def is_promotion(self) -> bool: ...


class BitBoard(int):    
    def as_array(self, shape : Sequence[int] = None, reversed: bool = False, as_list = False) -> np.ndarray | list: ...
    def more_then_one(self) -> bool: ...
    def has_two_bits(self) -> bool: ...
    def get_last_bit(self) -> int: ...
    def count_bits(self) -> int: ...
    def is_filled(self, square: int | str) -> bool: ... 
    def to_squares(self) -> list[int]: ...

class Board:
    def __init__(self, fen: str = None): ...

    @property
    def white_pawns(self) -> BitBoard: ...
    
    @property
    def white_knights(self) -> BitBoard: ...
    
    @property
    def white_bishops(self) -> BitBoard: ...
    
    @property
    def white_rooks(self) -> BitBoard: ...
    
    @property
    def white_queens(self) -> BitBoard: ...
    
    @property
    def white_king(self) -> BitBoard: ...

    @property
    def black_pawns(self) -> BitBoard: ...
    
    @property
    def black_knights(self) -> BitBoard: ...
    
    @property
    def black_bishops(self) -> BitBoard: ...
    
    @property
    def black_rooks(self) -> BitBoard: ...
    
    @property
    def black_queens(self) -> BitBoard: ...
    
    @property
    def black_king(self) -> BitBoard: ...

    @property
    def white_occ(self) -> BitBoard: ...

    @property
    def black_occ(self) -> BitBoard: ...

    @property
    def all_occ(self) -> BitBoard: ...

    @property
    def castles(self) -> int: ...

    @property
    def castles_str(self) -> str: ...
    
    @property
    def nmoves(self) -> int: ...

    @property
    def fifty_counter(self) -> int: ...

    @property
    def en_passant_sqr(self) -> int: ...

    def step(self, step: Move | str | int) -> None: ...
    def undo(self) -> None: ...
    def perft(self, deep: int, pretty: bool = False, no_print: bool = False) -> int: ...
    def generate_legal_moves(self) -> list[Move]: ...
    def as_array(self, shape = Sequence[int], reversed: bool = False, as_list: bool = False) -> list | np.ndarray: ...
    def as_table(self, shape = Sequence[int], reversed: bool = False, as_list: bool = False) -> list | np.ndarray: ...
    def on_square(self, square: int) -> Move: ...
    def owned_by(self, square: int) -> int: ...
    def get_played_moves(self) -> list[Move]: ...
    def reset(self) -> None: ...
    def is_check(self) -> bool: ...
    def is_insufficient_material(self) -> bool: ...
    def is_threefold(self) -> bool: ...
    def is_fifty_moves(self) -> bool: ...
    def get_attackers_map(self, square: int) -> int: ...
    def get_moves_of(self, square: int) -> list[Move]: ...
    def copy(self) -> Board: ...
    def state(self, can_move: bool) -> int: ...
    def find(self, piece: int) -> list[int]: ...

